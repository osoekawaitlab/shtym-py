{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"shtym","text":"<p>AI-powered summary filter that distills any command's output.</p>"},{"location":"#overview","title":"Overview","text":"<p>Shtym is a command wrapper designed to reduce context size for both human users and AI coding agents. It wraps command execution and, when an LLM is available, summarizes the output; otherwise it passes output through unchanged.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install shtym\n\n# with Ollama support (requires a running Ollama instance)\npip install \"shtym[ollama]\"\n</code></pre>"},{"location":"#configuration","title":"Configuration","text":"<p>When using Ollama, you can configure the behavior using environment variables:</p> <ul> <li><code>SHTYM_LLM_SETTINGS__BASE_URL</code>: Ollama server URL (defaults to <code>http://localhost:11434</code>)</li> <li><code>SHTYM_LLM_SETTINGS__MODEL</code>: Model to use (defaults to <code>gpt-oss:20b</code>)</li> </ul> <p>Example: <pre><code>export SHTYM_LLM_SETTINGS__BASE_URL=http://localhost:11434\nexport SHTYM_LLM_SETTINGS__MODEL=llama2\nstym run pytest tests/\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p>Wrap any command with <code>stym run</code>:</p> <pre><code># Run tests\nstym run pytest tests/\n\n# Run linter\nstym run ruff check .\n\n# Build project\nstym run npm run build\n\n# Any command with options\nstym run ls -la\n\n# Pipe output to other commands\nstym run pytest tests/ | grep FAILED\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Exit code inheritance: Shtym preserves the wrapped command's exit code, making it CI/CD friendly</li> <li>Clean stdout: Output contains only command results, no progress indicators or metadata</li> <li>Transparent wrapper: Works seamlessly with existing workflows and scripts</li> <li>Optional LLM summaries: If Ollama is available, output is summarized by the configured model; otherwise passthrough is used automatically</li> </ul>"},{"location":"#design-philosophy","title":"Design Philosophy","text":"<p>Shtym follows Unix conventions for command wrappers (like <code>sudo</code>, <code>timeout</code>, <code>time</code>):</p> <ul> <li>Executes commands as subprocesses</li> <li>Inherits and propagates exit codes exactly</li> <li>Maintains clean stdout for composability</li> <li>Enables reliable integration with automated workflows</li> </ul>"},{"location":"#development","title":"Development","text":"<p>For development documentation, see:</p> <ul> <li>Architecture Overview</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"configuration/","title":"Configuration","text":"<p>Shtym uses environment variables for configuration.</p>"},{"location":"configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"configuration/#shtym_llm_settings__base_url","title":"<code>SHTYM_LLM_SETTINGS__BASE_URL</code>","text":"<p>Description: Ollama server URL</p> <p>Default: <code>http://localhost:11434</code></p> <p>Example: <pre><code>export SHTYM_LLM_SETTINGS__BASE_URL=http://ollama.example.com:11434\n</code></pre></p>"},{"location":"configuration/#shtym_llm_settings__model","title":"<code>SHTYM_LLM_SETTINGS__MODEL</code>","text":"<p>Description: Ollama model name to use for output summarization</p> <p>Default: <code>gpt-oss:20b</code></p> <p>Example: <pre><code>export SHTYM_LLM_SETTINGS__MODEL=llama2\n</code></pre></p> <p>Notes: - Empty strings or whitespace-only values are treated as unset (falls back to default) - If the specified model is not available in Ollama, shtym silently falls back to PassThrough mode</p>"},{"location":"adr/0000-adr-template/","title":"ADR 0000: This is ADR Template and Short Title of the Architectural Decision Goes Here","text":""},{"location":"adr/0000-adr-template/#status","title":"Status","text":"<p>[Proposed | Accepted | Deprecated | Superseded]</p>"},{"location":"adr/0000-adr-template/#date","title":"Date","text":"<p>YYYY-MM-DD</p>"},{"location":"adr/0000-adr-template/#context","title":"Context","text":"<p>Describe the context and problem statement. What is the architectural challenge that needs to be addressed? Include any relevant constraints or requirements that influenced the decision.</p>"},{"location":"adr/0000-adr-template/#decision","title":"Decision","text":"<p>State the architectural decision clearly and concisely. What specific approach, technology, pattern, or solution was chosen?</p>"},{"location":"adr/0000-adr-template/#rationale","title":"Rationale","text":"<p>Explain the reasoning that led to this decision. Why was this particular option selected among the alternatives? Include relevant factors such as:</p> <ul> <li>Technical considerations</li> <li>Business requirements</li> <li>Team capabilities</li> <li>Time constraints</li> <li>Cost implications</li> </ul>"},{"location":"adr/0000-adr-template/#implications","title":"Implications","text":""},{"location":"adr/0000-adr-template/#positive-implications","title":"Positive Implications","text":"<p>List the benefits and positive outcomes expected from this decision.</p>"},{"location":"adr/0000-adr-template/#concerns","title":"Concerns","text":"<p>List potential challenges, risks, or negative consequences along with possible mitigation strategies.</p>"},{"location":"adr/0000-adr-template/#alternatives","title":"Alternatives","text":"<p>Describe other options that were considered and why they were not selected. For each alternative, briefly explain:</p> <ul> <li>Key characteristics</li> <li>Pros and cons relative to the chosen solution</li> <li>Reasons for rejection</li> </ul>"},{"location":"adr/0000-adr-template/#future-direction","title":"Future Direction","text":"<p>Outline any follow-up actions, future considerations, or potential changes that might be necessary as a result of this decision. Include potential triggers for revisiting this decision.</p>"},{"location":"adr/0000-adr-template/#references","title":"References","text":"<p>List any relevant documents, articles, books, or other resources that supported this decision:</p> <ul> <li>Links to relevant documentation</li> <li>Research materials</li> <li>Benchmarks or performance data</li> <li>Team discussions or meeting notes</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/","title":"ADR 0001: Keep stdout Clean for AI and Human Consumption","text":""},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#status","title":"Status","text":"<p>Accepted (Amended 2025-11-21)</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#date","title":"Date","text":"<p>2025-11-20</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#context","title":"Context","text":"<p>The shtym tool is designed as a command-line filter that summarizes input using AI. Its primary purpose is to reduce context size for both human users and AI coding agents working in terminal environments. Users need to pipe command output through shtym and receive only the essential summary without any visual clutter or formatting.</p> <p>In modern development workflows, AI coding agents are increasingly consuming command-line output programmatically. Additionally, humans often need to copy-paste terminal output or chain commands together. Any extra formatting, progress indicators, or decorative elements in stdout would interfere with these use cases and defeat the purpose of context reduction.</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#decision","title":"Decision","text":"<p>Keep stdout exclusively for AI-generated summaries. All other output (progress indicators, error messages, logging, metadata) must go to stderr or other channels.</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#rationale","title":"Rationale","text":"<ul> <li>Context reduction goal: Adding any extra formatting to stdout would contradict the core purpose of reducing context size</li> <li>AI agent compatibility: AI coding agents can cleanly consume stdout without parsing decorative elements</li> <li>Unix philosophy: Following the principle that stdout carries the primary data output while stderr carries metadata</li> <li>Composability: Users can reliably pipe shtym output to other commands or redirect it to files</li> <li>Copy-paste friendliness: Humans can directly use the stdout content without manual cleanup</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#implications","title":"Implications","text":""},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clean integration with Unix pipes and redirections</li> <li>AI coding agents can parse output without special handling</li> <li>Predictable behavior: stdout always contains exactly the summary</li> <li>No dependency on terminal capabilities or detection logic</li> <li>Users can easily capture only the summary: <code>command | shtym &gt; summary.txt</code></li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#concerns","title":"Concerns","text":"<ul> <li>Users won't see progress indicators in stdout (mitigation: use stderr for progress)</li> <li>Debugging information must go to stderr (mitigation: implement proper logging levels)</li> <li>May feel \"bare\" compared to modern CLI tools with rich formatting (mitigation: this is intentional for our use case)</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#alternatives","title":"Alternatives","text":""},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#rich-cli-with-formatting-controls","title":"Rich CLI with formatting controls","text":"<p>Using libraries like rich or colorama to provide formatted output with an option to disable it.</p> <ul> <li>Pros: Better visual experience for interactive use, can show progress elegantly</li> <li>Cons: Adds complexity, requires terminal detection, users must remember to use <code>--plain</code> flags, increases dependencies</li> <li>Reason for rejection: Goes against the core philosophy of simplicity and context reduction</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#json-output-mode","title":"JSON output mode","text":"<p>Wrapping the summary in JSON with metadata fields.</p> <ul> <li>Pros: Machine-readable, can include metadata</li> <li>Cons: Increases output size, requires parsing, defeats context reduction purpose</li> <li>Reason for rejection: Contradicts the goal of minimal context; metadata can go to stderr if needed</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#mixed-output-with-delimiters","title":"Mixed output with delimiters","text":"<p>Using special delimiters to separate summary from other information in stdout.</p> <ul> <li>Pros: Can include both summary and metadata in one stream</li> <li>Cons: Users must parse delimiters, still increases output size, fragile</li> <li>Reason for rejection: Adds unnecessary complexity and increases context size</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#future-direction","title":"Future Direction","text":"<p>This decision is foundational and unlikely to change. However, we should:</p> <ul> <li>Implement proper stderr logging for progress and debug information</li> <li>Consider environment variables or config files for verbosity control (affecting stderr only)</li> <li>Document this design choice clearly for users and contributors</li> <li>Revisit if a compelling use case emerges that requires stdout metadata (trigger: multiple user requests for structured output)</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#references","title":"References","text":"<ul> <li>Unix Philosophy: \"Write programs that do one thing and do it well\"</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#amendment-2025-11-21","title":"Amendment (2025-11-21)","text":""},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#what-changed","title":"What Changed","text":"<p>The original ADR assumed pipe-based usage where users pipe command output into shtym:</p> <ul> <li>Original assumption: <code>pytest tests/ | stym</code></li> <li>Amended to: <code>stym run pytest tests/</code> (wrapper pattern with subcommand)</li> </ul> <p>The core principle of keeping stdout clean remains unchanged. Only the invocation pattern has changed from pipe-based to wrapper-based.</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#reason-for-amendment","title":"Reason for Amendment","text":"<p>Exit code inheritance is a critical requirement for development workflows. When tests fail, build commands error, or linters find issues, the command must exit with a non-zero status to integrate properly with CI/CD pipelines and developer scripts.</p> <p>Technical constraint:</p> <ul> <li>Pipe pattern (<code>command | stym</code>): The wrapper process cannot access the exit code of the piped command. The pipeline's exit code would always be shtym's exit code, losing the original command's status.</li> <li>Wrapper pattern (<code>stym run command args</code>): The wrapper can execute the command as a subprocess, capture its exit code, and propagate it via <code>sys.exit(child_exit_code)</code>.</li> </ul> <p>Unix precedent: Standard Unix wrapper commands (sudo, timeout, time) all inherit their child process exit codes. This is the established pattern for command wrappers.</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#impact-on-original-adr","title":"Impact on Original ADR","text":"<p>Unchanged:</p> <ul> <li>Clean stdout principle: stdout still contains only the primary data (command output or AI summary)</li> <li>stderr for metadata: progress indicators and errors still go to stderr</li> <li>Composability: shtym output can still be piped to other commands (<code>stym run pytest | grep ERROR</code>)</li> <li>Unix philosophy: still doing one thing well with clean interfaces</li> </ul> <p>Changed:</p> <ul> <li>Invocation pattern: wrapper style instead of pipe style</li> <li>Data flow: shtym executes the command rather than reading from stdin</li> <li>Exit code: properly inherited from child process</li> </ul> <p>Compatibility note: The wrapper pattern is more composable than originally described. Users can still pipe shtym's output:</p> <pre><code>stym run pytest tests/ | grep \"FAILED\"\nstym run npm test | tee test-output.txt\n</code></pre> <p>The clean stdout principle enables these compositions while also preserving exit codes.</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/","title":"ADR 0002: Use argparse for CLI Implementation","text":""},{"location":"adr/0002-use-argparse-for-cli-implementation/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#date","title":"Date","text":"<p>2025-11-20</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#context","title":"Context","text":"<p>Following ADR-0001's decision to keep stdout clean, shtym needs a CLI argument parsing library. Python offers several options including the standard library's argparse, and third-party libraries like click and typer that provide rich terminal UI features.</p> <p>The tool's design philosophy emphasizes simplicity and minimal dependencies. Since shtym's primary function is piping input through AI summarization, the CLI surface area is intentionally small. Complex interactive features, auto-completion, or rich formatting would not align with the clean stdout principle established in ADR-0001.</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#decision","title":"Decision","text":"<p>Use argparse from Python's standard library for CLI argument parsing.</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#rationale","title":"Rationale","text":"<ul> <li>Zero external dependencies: argparse is part of Python's standard library, requiring no additional packages</li> <li>Sufficient functionality: Provides all necessary features (flags, options, help text, subcommands if needed)</li> <li>No rich UI features: Lack of built-in colors, prompts, and progress bars aligns with ADR-0001's philosophy</li> <li>Simplicity: Straightforward API without magic decorators or complex abstractions</li> <li>Stability: Part of the standard library with guaranteed long-term support</li> <li>Predictability: Well-documented behavior, no surprises from framework-specific conventions</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#implications","title":"Implications","text":""},{"location":"adr/0002-use-argparse-for-cli-implementation/#positive-implications","title":"Positive Implications","text":"<ul> <li>No dependency management overhead</li> <li>Works out-of-the-box in any Python environment</li> <li>Lightweight CLI with minimal overhead</li> <li>Clear, explicit argument definitions without decorators</li> <li>Easy to test with standard mocking techniques</li> <li>Reduces package size and installation complexity</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#concerns","title":"Concerns","text":"<ul> <li>Manual help text formatting (mitigation: acceptable trade-off for simplicity)</li> <li>No built-in shell completion (mitigation: can add via argcomplete if needed, but likely unnecessary for our simple CLI)</li> <li>More verbose than decorator-based frameworks (mitigation: explicit is better than implicit, aids readability)</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#alternatives","title":"Alternatives","text":""},{"location":"adr/0002-use-argparse-for-cli-implementation/#click","title":"Click","text":"<p>A popular third-party CLI framework with decorator-based API.</p> <ul> <li>Pros: Elegant decorator syntax, rich ecosystem, wide adoption</li> <li>Cons: External dependency, includes rich terminal features we don't need (colors, prompts, progress bars), adds framework magic</li> <li>Reason for rejection: Adds unnecessary dependency and features that contradict ADR-0001's clean output philosophy</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#typer","title":"Typer","text":"<p>Modern CLI framework built on top of Click with type hints.</p> <ul> <li>Pros: Type-safe, modern Python syntax, automatic help generation from type hints</li> <li>Cons: External dependency, even heavier than Click (depends on Click + rich), includes rich terminal UI we don't want</li> <li>Reason for rejection: Same concerns as Click, plus additional dependency weight and unwanted UI features</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#python-fire","title":"Python Fire","text":"<p>Automatically generates CLIs from Python objects.</p> <ul> <li>Pros: Zero boilerplate, automatic CLI generation</li> <li>Cons: External dependency, magic behavior, less explicit control, harder to understand CLI structure</li> <li>Reason for rejection: Too much magic, lack of explicit control contradicts our simplicity goal</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#future-direction","title":"Future Direction","text":"<p>This decision is expected to remain stable. Potential triggers for revisiting:</p> <ul> <li>Complex subcommand structure emerges: If shtym grows to require many subcommands with nested options, a richer framework might become beneficial (unlikely given the tool's focused scope)</li> <li>Shell completion becomes essential: If users strongly request shell completion, we could add argcomplete as an optional dependency</li> <li>Standard library evolution: If argparse gains significant improvements or a better alternative enters the standard library</li> </ul> <p>For now, argparse provides everything needed for shtym's straightforward CLI.</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#references","title":"References","text":"<ul> <li>ADR-0001: Keep stdout Clean for AI and Human Consumption</li> <li>Python argparse documentation</li> <li>PEP 389: argparse - New Command Line Parsing Module</li> </ul>"},{"location":"adr/0003-adopt-layered-architecture/","title":"ADR 0003: Adopt Layered Architecture","text":""},{"location":"adr/0003-adopt-layered-architecture/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0003-adopt-layered-architecture/#date","title":"Date","text":"<p>2025-11-21</p>"},{"location":"adr/0003-adopt-layered-architecture/#context","title":"Context","text":"<p>Shtym needs to implement subprocess execution and output handling for pass-through mode (Issue #3), with future expansion to LLM integration. The current flat module structure (cli.py, core.py) lacks clear separation of concerns, which will make future LLM integration and testing more difficult.</p> <p>A clear architectural pattern is needed to:</p> <ul> <li>Separate I/O concerns from business logic</li> <li>Enable easy testing without actual I/O operations</li> <li>Provide clear boundaries for future LLM integration</li> <li>Maintain code organization as functionality grows</li> </ul>"},{"location":"adr/0003-adopt-layered-architecture/#decision","title":"Decision","text":"<p>Adopt a layered architecture with four distinct layers:</p> <pre><code>src/shtym/\n\u251c\u2500\u2500 _version.py           # Version constant\n\u251c\u2500\u2500 __init__.py           # Package exports\n\u251c\u2500\u2500 cli.py                # Presentation Layer\n\u251c\u2500\u2500 application.py        # Application Layer\n\u251c\u2500\u2500 domain.py             # Domain Layer\n\u2514\u2500\u2500 infrastructure/       # Infrastructure Layer\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 stdio.py          # stdout writing\n</code></pre> <p>Layer responsibilities:</p> <ul> <li>Presentation Layer (cli.py): CLI argument parsing, error handling, user-facing messages</li> <li>Application Layer (application.py): Orchestration of domain and infrastructure components</li> <li>Domain Layer (domain.py): Core text processing logic (pass-through, future LLM summarization)</li> <li>Infrastructure Layer (infrastructure/): External I/O operations (stdio, future LLM API clients)</li> </ul>"},{"location":"adr/0003-adopt-layered-architecture/#rationale","title":"Rationale","text":"<ul> <li>Testability: Each layer can be tested independently. Infrastructure I/O can be mocked in unit tests</li> <li>Separation of concerns: Clear boundaries between user interface, orchestration, business logic, and external dependencies</li> <li>Future LLM integration: LLM clients will naturally fit in infrastructure layer alongside stdio</li> <li>Maintainability: Changes to I/O mechanisms or CLI don't affect business logic</li> <li>Standard pattern: Layered architecture is well-understood and documented</li> <li>Lightweight: Only four layers, avoiding over-engineering for small project</li> </ul>"},{"location":"adr/0003-adopt-layered-architecture/#implications","title":"Implications","text":""},{"location":"adr/0003-adopt-layered-architecture/#positive-implications","title":"Positive Implications","text":"<ul> <li>Unit tests can focus on pure logic without I/O</li> <li>Infrastructure components are swappable (e.g., different LLM providers)</li> <li>Clear mental model for future contributors</li> <li>Dependency flow is explicit (presentation \u2192 application \u2192 domain \u2190 infrastructure)</li> <li>Easy to add new infrastructure adapters (file I/O, network, etc.)</li> </ul>"},{"location":"adr/0003-adopt-layered-architecture/#concerns","title":"Concerns","text":"<ul> <li>Slightly more files than flat structure (mitigation: only 3-4 additional modules, manageable)</li> <li>Requires discipline to maintain layer boundaries (mitigation: documented in ADR, enforced in code review)</li> <li>Possible over-engineering for simple pass-through (mitigation: pattern pays off immediately when LLM integration begins)</li> </ul>"},{"location":"adr/0003-adopt-layered-architecture/#alternatives","title":"Alternatives","text":""},{"location":"adr/0003-adopt-layered-architecture/#flat-module-structure","title":"Flat Module Structure","text":"<p>Keep current flat structure with cli.py and core.py.</p> <ul> <li>Pros: Fewer files, simpler initial setup</li> <li>Cons: Tight coupling between I/O and logic, hard to test, unclear where to add LLM clients</li> <li>Reason for rejection: Technical debt accumulates quickly; refactoring later is harder than starting with clear structure</li> </ul>"},{"location":"adr/0003-adopt-layered-architecture/#hexagonal-architecture-ports-and-adapters","title":"Hexagonal Architecture (Ports and Adapters)","text":"<p>Use ports (interfaces) and adapters pattern.</p> <ul> <li>Pros: Maximum flexibility, very testable, clear boundaries</li> <li>Cons: More abstract, requires interfaces/protocols for every boundary, overhead for small project</li> <li>Reason for rejection: Too much ceremony for current needs; layered architecture provides similar benefits with less complexity</li> </ul>"},{"location":"adr/0003-adopt-layered-architecture/#mvc-pattern","title":"MVC Pattern","text":"<p>Adopt Model-View-Controller pattern.</p> <ul> <li>Pros: Well-known web pattern</li> <li>Cons: Designed for UI interactions, not for CLI command wrapper tools; controller/view distinction unclear for CLI</li> <li>Reason for rejection: Not a natural fit for CLI command wrapper tools</li> </ul>"},{"location":"adr/0003-adopt-layered-architecture/#future-direction","title":"Future Direction","text":"<p>The layered architecture should remain stable through LLM integration. Potential triggers for revisiting:</p> <ul> <li>Infrastructure layer grows too large: If we add many infrastructure adapters (multiple LLM providers, various I/O sources), consider splitting into subdirectories (infrastructure/llm/, infrastructure/io/)</li> <li>Cross-cutting concerns emerge: If we need logging, metrics, or tracing across all layers, consider aspect-oriented patterns or middleware</li> <li>Domain logic becomes complex: If text processing logic grows significantly, consider splitting domain.py into multiple modules or introducing domain-driven design patterns</li> </ul> <p>For now, this lightweight four-layer structure provides the right balance of organization and simplicity.</p>"},{"location":"adr/0003-adopt-layered-architecture/#references","title":"References","text":"<ul> <li>Issue #3: Implement basic pass-through mode</li> <li>ADR-0001: Keep stdout Clean for AI and Human Consumption</li> <li>Layered Architecture Pattern</li> </ul>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/","title":"ADR 0004: Do Not Implement Stdin Pipe Mode","text":""},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#date","title":"Date","text":"<p>2025-11-21</p>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#context","title":"Context","text":"<p>When designing shtym's invocation pattern, there are two common approaches for wrapping command-line tools:</p> <ol> <li>Pipe mode: <code>command | shtym</code> - reads from stdin, writes to stdout</li> <li>Wrapper mode: <code>shtym command args</code> - executes command as subprocess</li> </ol> <p>The pipe mode (<code>command | shtym</code>) appears natural for Unix pipeline tools and aligns with the \"filter\" concept. However, this approach has a fundamental technical limitation that conflicts with critical development workflow requirements.</p>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#decision","title":"Decision","text":"<p>Do NOT implement stdin pipe mode (<code>command | shtym</code>). Shtym will exclusively use wrapper mode (<code>shtym command args</code>).</p>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#rationale","title":"Rationale","text":"<p>Technical constraint - Exit code inheritance:</p> <p>In development workflows, exit codes are critical for:</p> <ul> <li>CI/CD pipeline control (fail on test failures)</li> <li>Build automation (stop on compilation errors)</li> <li>Developer scripts (conditional execution based on success/failure)</li> <li>Shell scripting (<code>set -e</code> to fail on errors)</li> </ul> <p>Pipe mode limitation:</p> <pre><code>pytest tests/ | stym\necho $?  # Always returns stym's exit code, not pytest's\n</code></pre> <p>When using pipes, the shell pipeline's exit code is determined by the last command (<code>stym</code>), not the piped command (<code>pytest</code>). There is no standard mechanism for <code>stym</code> to access <code>pytest</code>'s exit code in this scenario.</p> <p>While <code>$PIPESTATUS</code> or <code>set -o pipefail</code> can provide workarounds, they:</p> <ul> <li>Require users to remember special shell features</li> <li>Don't work consistently across shells (bash vs zsh vs fish)</li> <li>Add cognitive overhead and documentation burden</li> <li>Break the principle of least surprise</li> </ul> <p>Wrapper mode advantage:</p> <pre><code>stym run pytest tests/\necho $?  # Returns pytest's exit code\n</code></pre> <p>Wrapper mode executes the command as a subprocess, captures its exit code via <code>subprocess.run()</code>, and propagates it via <code>sys.exit(child_returncode)</code>. This works reliably and requires no special user knowledge.</p> <p>Unix precedent:</p> <p>Standard Unix wrapper commands use this pattern:</p> <ul> <li><code>sudo command</code> - inherits exit code</li> <li><code>timeout command</code> - inherits exit code</li> <li><code>time command</code> - inherits exit code</li> <li><code>nice command</code> - inherits exit code</li> </ul> <p>Composability is preserved:</p> <p>Users can still pipe shtym's output:</p> <pre><code>stym run pytest tests/ | grep \"FAILED\"\nstym run npm test | tee output.txt\n</code></pre> <p>The wrapper pattern doesn't sacrifice composability; it enhances it by adding exit code reliability.</p>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#implications","title":"Implications","text":""},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#positive-implications","title":"Positive Implications","text":"<ul> <li>Exit codes work correctly without special shell configuration</li> <li>Matches Unix wrapper command conventions</li> <li>No documentation needed for <code>$PIPESTATUS</code> workarounds</li> <li>Works identically across all shells</li> <li>Integrates seamlessly with CI/CD systems</li> <li>Composable with pipes while preserving exit codes</li> </ul>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#concerns","title":"Concerns","text":"<ul> <li>Deviates from traditional \"filter\" mental model (mitigation: wrapper is more accurate for our use case)</li> <li>Users familiar with <code>command | filter</code> pattern may expect pipe mode (mitigation: clear documentation and error messages)</li> <li>Cannot process pre-existing piped input like <code>cat file | stym</code> (mitigation: not a target use case; use <code>stym run cat file</code> instead)</li> </ul>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#alternatives","title":"Alternatives","text":""},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#implement-pipe-mode-only","title":"Implement Pipe Mode Only","text":"<p>Use <code>command | stym</code> pattern exclusively.</p> <ul> <li>Pros: Familiar Unix filter pattern, simple mental model</li> <li>Cons: Cannot inherit exit codes, breaks CI/CD workflows, requires shell-specific workarounds</li> <li>Reason for rejection: Exit code inheritance is non-negotiable for development tool integration</li> </ul>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#implement-both-modes","title":"Implement Both Modes","text":"<p>Support both <code>command | stym</code> and <code>stym run command</code> with auto-detection.</p> <ul> <li>Pros: Maximum flexibility, supports both use cases</li> <li>Cons: Complex implementation, confusing UX (which mode is active?), pipe mode still can't solve exit code problem, doubles testing surface area</li> <li>Reason for rejection: Pipe mode provides no benefits over wrapper mode while adding complexity</li> </ul>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#use-special-flags-for-exit-code","title":"Use Special Flags for Exit Code","text":"<p>Implement pipe mode with <code>--exit-code=FILE</code> to write exit code separately.</p> <ul> <li>Pros: Solves exit code problem while keeping pipe mode</li> <li>Cons: Extremely awkward UX, requires temp files, fragile, no Unix precedent for this pattern</li> <li>Reason for rejection: Trading one problem for multiple worse problems</li> </ul>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#future-direction","title":"Future Direction","text":"<p>This decision is expected to remain stable. Potential triggers for revisiting:</p> <ul> <li>New shell features: If future shells provide standard mechanisms for filters to access piped command exit codes (unlikely; would break 50 years of Unix convention)</li> <li>User demand: If significant user feedback requests pipe mode despite exit code limitations (would require clear documentation of the tradeoff)</li> </ul> <p>For now, wrapper mode provides all benefits of pipe mode plus exit code inheritance, making it strictly superior for our use case.</p>"},{"location":"adr/0004-do-not-implement-stdin-pipe-mode/#references","title":"References","text":"<ul> <li>ADR-0001: Keep stdout Clean for AI and Human Consumption (Amended to use wrapper pattern)</li> <li>ADR-0005: Inherit Child Process Exit Codes</li> <li>Unix Pipe Documentation</li> </ul>"},{"location":"adr/0005-inherit-child-process-exit-codes/","title":"ADR 0005: Inherit Child Process Exit Codes","text":""},{"location":"adr/0005-inherit-child-process-exit-codes/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0005-inherit-child-process-exit-codes/#date","title":"Date","text":"<p>2025-11-21</p>"},{"location":"adr/0005-inherit-child-process-exit-codes/#context","title":"Context","text":"<p>Shtym wraps command execution to filter or summarize output. As a command wrapper, it must decide how to handle the exit code (return code) of the child process it executes.</p> <p>Exit codes are fundamental to Unix command composition and automation:</p> <ul> <li>Exit code 0 indicates success</li> <li>Non-zero exit codes indicate failure (1-255)</li> <li>Scripts and CI/CD systems rely on exit codes for flow control</li> </ul> <p>When shtym executes <code>stym run pytest tests/</code>, there are several options for what exit code shtym itself should return.</p>"},{"location":"adr/0005-inherit-child-process-exit-codes/#decision","title":"Decision","text":"<p>Shtym MUST inherit and propagate the child process exit code exactly as-is. If the child process exits with code N, shtym exits with code N.</p> <p>Implementation:</p> <pre><code>result = subprocess.run(command, ...)\nsys.exit(result.returncode)  # Inherit exactly\n</code></pre>"},{"location":"adr/0005-inherit-child-process-exit-codes/#rationale","title":"Rationale","text":"<p>Critical for development workflows:</p> <p>Development commands have meaningful exit codes:</p> <ul> <li><code>pytest tests/</code> \u2192 0 if all tests pass, 1 if any test fails</li> <li><code>mypy src/</code> \u2192 0 if types are correct, 1 if type errors exist</li> <li><code>npm test</code> \u2192 0 if tests pass, non-zero if tests fail</li> <li><code>make build</code> \u2192 0 if build succeeds, non-zero if build fails</li> </ul> <p>If shtym returned its own exit code (e.g., always 0), it would break:</p> <ul> <li>CI/CD pipelines that fail builds on test failures</li> <li>Pre-commit hooks that block commits on linter errors</li> <li>Makefiles with conditional targets</li> <li>Shell scripts using <code>set -e</code> to fail fast</li> <li>Developer muscle memory (<code>command &amp;&amp; next-step</code>)</li> </ul> <p>Unix wrapper command convention:</p> <p>Standard Unix wrapper commands inherit child exit codes:</p> <pre><code>$ sudo false; echo $?\n1  # Inherits false's exit code\n\n$ timeout 5 false; echo $?\n1  # Inherits false's exit code\n\n$ time false; echo $?\n1  # Inherits false's exit code\n\n$ nice false; echo $?\n1  # Inherits false's exit code\n</code></pre> <p>This is established Unix convention for wrapper commands. Users expect wrappers to be transparent with respect to exit codes.</p> <p>Principle of least surprise:</p> <p>Developers expect:</p> <pre><code>stym run pytest tests/ &amp;&amp; echo \"Tests passed\"\n</code></pre> <p>To behave identically to:</p> <pre><code>pytest tests/ &amp;&amp; echo \"Tests passed\"\n</code></pre> <p>If shtym returned a different exit code, it would violate the principle of least surprise and be unusable in automated workflows.</p> <p>No loss of information:</p> <p>Shtym has no reason to override the child's exit code:</p> <ul> <li>Shtym's own errors (invalid arguments, etc.) prevent child execution, so there's no conflict</li> <li>Child execution errors are reflected in the child's exit code</li> <li>Shtym's purpose (filtering output) doesn't change the success/failure of the underlying command</li> </ul>"},{"location":"adr/0005-inherit-child-process-exit-codes/#implications","title":"Implications","text":""},{"location":"adr/0005-inherit-child-process-exit-codes/#positive-implications","title":"Positive Implications","text":"<ul> <li>Works seamlessly in CI/CD pipelines</li> <li>Integrates with shell scripting patterns (<code>&amp;&amp;</code>, <code>||</code>, <code>set -e</code>)</li> <li>Matches Unix wrapper command conventions</li> <li>Preserves all semantic information from child process</li> <li>No special documentation needed (behavior is intuitive)</li> <li>Enables <code>stym</code> to be used as a drop-in wrapper:</li> </ul> <pre><code>alias pytest='stym run pytest'  # Transparent wrapper\n</code></pre>"},{"location":"adr/0005-inherit-child-process-exit-codes/#concerns","title":"Concerns","text":"<ul> <li>If shtym itself encounters an error while the child succeeds, it cannot signal its own error via exit code (mitigation: errors that prevent output filtering prevent child execution, so no conflict exists; errors during filtering can be logged to stderr without affecting exit code)</li> <li>Edge case: if child exits with code 127 (command not found) vs shtym exits with 127, these are indistinguishable (mitigation: acceptable, as both indicate the same problem from the user's perspective)</li> </ul>"},{"location":"adr/0005-inherit-child-process-exit-codes/#alternatives","title":"Alternatives","text":""},{"location":"adr/0005-inherit-child-process-exit-codes/#return-shtyms-own-exit-code","title":"Return Shtym's Own Exit Code","text":"<p>Shtym returns 0 on successful execution (child ran successfully), regardless of child exit code.</p> <ul> <li>Pros: Distinguishes \"shtym worked\" from \"child worked\"</li> <li>Cons: Breaks all CI/CD integration, violates Unix conventions, unusable in automated workflows</li> <li>Reason for rejection: Makes shtym unsuitable for its primary use case (development command wrapping)</li> </ul>"},{"location":"adr/0005-inherit-child-process-exit-codes/#return-combined-exit-code","title":"Return Combined Exit Code","text":"<p>Use bitwise OR or custom encoding to combine shtym's status and child's exit code.</p> <ul> <li>Pros: Theoretically provides both pieces of information</li> <li>Cons: No Unix precedent, requires custom parsing, breaks standard exit code semantics (0 = success), confusing UX</li> <li>Reason for rejection: Violates Unix exit code conventions; no tool expects this pattern</li> </ul>"},{"location":"adr/0005-inherit-child-process-exit-codes/#exit-code-passthrough-flag","title":"Exit Code Passthrough Flag","text":"<p>Default to inheriting child exit code, but provide <code>--own-exit-code</code> flag to return shtym's status instead.</p> <ul> <li>Pros: Flexibility for edge cases</li> <li>Cons: Complicates UX, almost never useful, adds testing burden, invites misuse</li> <li>Reason for rejection: No identified use case for the flag; YAGNI (You Aren't Gonna Need It)</li> </ul>"},{"location":"adr/0005-inherit-child-process-exit-codes/#future-direction","title":"Future Direction","text":"<p>This decision is foundational and unlikely to change. Potential triggers for revisiting:</p> <ul> <li>Shtym processing errors: If shtym frequently encounters errors during output processing (e.g., LLM API failures) that need to be signaled separately from child failures (mitigation: log to stderr, use non-zero exit code only if child execution is prevented)</li> <li>Request for signal differentiation: If users need to distinguish \"child failed\" from \"shtym processing failed\" programmatically (mitigation: stderr logging, exit codes in different ranges, or status files if truly needed)</li> </ul> <p>For now, exact exit code inheritance provides the right semantics for a command wrapper and aligns with 50 years of Unix convention.</p>"},{"location":"adr/0005-inherit-child-process-exit-codes/#references","title":"References","text":"<ul> <li>ADR-0004: Do Not Implement Stdin Pipe Mode</li> <li>Exit Status (POSIX)</li> <li>Advanced Bash-Scripting Guide: Exit Codes With Special Meanings</li> </ul>"},{"location":"adr/0006-adopt-subcommand-architecture/","title":"ADR 0006: Adopt Subcommand Architecture","text":""},{"location":"adr/0006-adopt-subcommand-architecture/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0006-adopt-subcommand-architecture/#date","title":"Date","text":"<p>2025-11-21</p>"},{"location":"adr/0006-adopt-subcommand-architecture/#context","title":"Context","text":"<p>Shtym's CLI was initially designed as a simple wrapper: <code>stym command args</code>. While this works for the basic pass-through functionality, future LLM integration will require additional commands for configuration and status checking.</p> <p>With a simple wrapper design, commands like <code>stym status</code> would be ambiguous:</p> <ul> <li>Does it execute a command named \"status\"?</li> <li>Does it show shtym's LLM status?</li> </ul> <p>This ambiguity becomes critical when planning for future features:</p> <ul> <li><code>stym status</code> - Check LLM connection, API key validity, usage quota</li> <li><code>stym config</code> - View or modify configuration (API keys, default model)</li> <li><code>stym models</code> - List available LLM models</li> </ul> <p>Without a clear subcommand structure, these would either:</p> <ol> <li>Require awkward flag syntax (<code>stym --status</code>, <code>stym --config</code>)</li> <li>Use reserved word lists (fragile, prevents wrapping commands with those names)</li> <li>Be impossible to implement without breaking changes</li> </ol> <p>This decision must be made before the first release because changing from <code>stym command</code> to <code>stym run command</code> later would be a breaking change for all users.</p>"},{"location":"adr/0006-adopt-subcommand-architecture/#decision","title":"Decision","text":"<p>Adopt a subcommand architecture using argparse subparsers:</p> <pre><code>stym run &lt;command&gt; [args...]     # Execute and filter command\nstym status                      # (Future) Check LLM status\nstym config [options]            # (Future) Manage configuration\nstym models                      # (Future) List available models\n</code></pre>"},{"location":"adr/0006-adopt-subcommand-architecture/#rationale","title":"Rationale","text":"<p>Extensibility for LLM integration:</p> <ul> <li>Clear namespace for shtym operations vs wrapped commands</li> <li>No ambiguity: <code>stym status</code> always means shtym's status, never a command named \"status\"</li> <li>Natural place for future subcommands without breaking changes</li> </ul> <p>Industry standard pattern:</p> <ul> <li><code>git commit</code>, <code>docker run</code>, <code>kubectl get</code> - all use subcommands</li> <li><code>gh pr create</code>, <code>cargo build</code> - modern CLIs follow this pattern</li> <li>Users familiar with these tools will immediately understand shtym's structure</li> </ul> <p>Prevents future breaking changes:</p> <ul> <li>Adding <code>stym status</code> later would break users running <code>stym status</code> expecting command execution</li> <li>Changing from <code>stym pytest</code> to <code>stym run pytest</code> would break all existing scripts and documentation</li> <li>Must decide now, before first release and user adoption</li> </ul> <p>Explicit is better than implicit:</p> <ul> <li><code>stym run pytest</code> clearly indicates \"run this command through shtym\"</li> <li>No magic reserved words or special parsing rules</li> <li>Easier to explain and document</li> </ul>"},{"location":"adr/0006-adopt-subcommand-architecture/#implications","title":"Implications","text":""},{"location":"adr/0006-adopt-subcommand-architecture/#positive-implications","title":"Positive Implications","text":"<ul> <li>Future-proof: can add <code>status</code>, <code>config</code>, <code>models</code> without breaking changes</li> <li>Clear separation: shtym commands vs wrapped commands</li> <li>Industry-standard pattern: familiar to users</li> <li>Enables rich CLI features: help for each subcommand, subcommand-specific options</li> <li>Testable: each subcommand can be tested independently</li> </ul>"},{"location":"adr/0006-adopt-subcommand-architecture/#concerns","title":"Concerns","text":"<ul> <li>Slightly more typing: <code>stym run pytest</code> vs <code>stym pytest</code> (mitigation: users can create shell aliases if desired: <code>alias sr='stym run'</code>)</li> <li>Breaking change from current development version (mitigation: no released version yet, no users affected)</li> </ul>"},{"location":"adr/0006-adopt-subcommand-architecture/#alternatives","title":"Alternatives","text":""},{"location":"adr/0006-adopt-subcommand-architecture/#simple-wrapper-no-subcommands","title":"Simple Wrapper (No Subcommands)","text":"<p>Keep <code>stym command args</code> pattern, add shtym operations as flags.</p> <ul> <li>Pros: Shortest syntax for command execution</li> <li>Cons: Awkward operation syntax (<code>stym --status</code>), limited extensibility, confusing help output</li> <li>Reason for rejection: Cannot support rich LLM features without awkward UX</li> </ul>"},{"location":"adr/0006-adopt-subcommand-architecture/#reserved-word-list","title":"Reserved Word List","text":"<p>Use <code>stym command</code> but treat certain words (status, config, etc.) as special.</p> <ul> <li>Pros: Short command execution syntax</li> <li>Cons: Cannot wrap commands named \"status\", \"config\", etc.; fragile (must maintain reserved list); confusing (\"why doesn't <code>stym status</code> work?\")</li> <li>Reason for rejection: Too many edge cases and user confusion</li> </ul>"},{"location":"adr/0006-adopt-subcommand-architecture/#auto-detection","title":"Auto-Detection","text":"<p>Detect whether argument is a shtym subcommand or external command.</p> <ul> <li>Pros: \"Smart\" behavior</li> <li>Cons: Magic behavior, ambiguity (what if someone creates a command named \"status\"?), hard to predict</li> <li>Reason for rejection: Explicit is better than implicit; too much magic</li> </ul>"},{"location":"adr/0006-adopt-subcommand-architecture/#future-direction","title":"Future Direction","text":"<p>This subcommand structure is foundational and should remain stable. Expected future subcommands:</p> <p>Planned:</p> <ul> <li><code>stym status</code> - LLM connection and usage status</li> <li><code>stym config</code> - Configuration management</li> <li><code>stym models</code> - List and manage available models</li> </ul> <p>Possible:</p> <ul> <li><code>stym history</code> - Command execution history</li> <li><code>stym explain</code> - Explain previous command output</li> <li><code>stym debug</code> - Debug mode with verbose logging</li> </ul> <p>Triggers for revisiting:</p> <ul> <li>If <code>stym run</code> becomes overwhelming majority of usage and other subcommands rarely used (could add <code>run</code> as default, but keep subcommand structure)</li> <li>If user feedback strongly prefers shorter syntax despite tradeoffs (could add shell completion to make <code>stym run</code> typing easier)</li> </ul> <p>For now, explicit subcommand architecture provides the best balance of clarity, extensibility, and future-proofing.</p>"},{"location":"adr/0006-adopt-subcommand-architecture/#references","title":"References","text":"<ul> <li>Issue #3: Implement basic pass-through mode</li> <li>ADR-0002: Use argparse for CLI Implementation</li> <li>Git Subcommands</li> </ul>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/","title":"ADR 0007: Introduce Filter Abstraction for Output Processing","text":""},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#date","title":"Date","text":"<p>2025-11-21</p>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#context","title":"Context","text":"<p>Shtym is implementing basic pass-through mode (Issue #3) with the understanding that LLM-based output filtering will be added in the near future. The initial implementation could directly pass subprocess output to stdout, but this approach would require significant refactoring when adding LLM integration.</p> <p>Key considerations:</p> <ul> <li>Current requirement: Pass subprocess output through unchanged</li> <li>Future requirement: Filter output through LLM for summarization</li> <li>Goal: Minimize code changes when adding LLM integration</li> <li>Constraint: Avoid over-engineering for hypothetical requirements</li> </ul> <p>The question is whether to introduce an abstraction layer now or refactor later when LLM integration is implemented.</p>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#decision","title":"Decision","text":"<p>Introduce a <code>Filter</code> protocol and implement <code>PassThroughFilter</code> immediately, even though current behavior requires no transformation.</p> <p>Architecture:</p> <pre><code># Domain layer - Filter protocol\nclass Filter(Protocol):\n    def filter(self, text: str) -&gt; str: ...\n\n# Domain layer - PassThroughFilter implementation\nclass PassThroughFilter:\n    def filter(self, text: str) -&gt; str:\n        return text\n\n# Application layer - process_command uses Filter\ndef process_command(\n    command: list[str], text_filter: Filter\n) -&gt; ProcessedCommandResult:\n    result = run_command(command)\n    filtered_output = text_filter.filter(result.stdout)\n    return ProcessedCommandResult(filtered_output, result.returncode)\n\n# Presentation layer - CLI instantiates filter\ndef main() -&gt; None:\n    # ...\n    text_filter = PassThroughFilter()\n    result = process_command(args.command, text_filter)\n    write_stdout(result.filtered_output)\n</code></pre>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#rationale","title":"Rationale","text":"<p>Minimizes future LLM integration changes:</p> <p>Adding LLM filtering will only require:</p> <ol> <li>Implementing <code>LLMFilter</code> class with <code>filter(text: str) -&gt; str</code> method</li> <li>Changing CLI to instantiate <code>LLMFilter</code> instead of <code>PassThroughFilter</code></li> <li>Adding LLM configuration (API keys, model selection, etc.)</li> </ol> <p>No changes needed to:</p> <ul> <li><code>process_command</code> function</li> <li>Test infrastructure</li> <li>Exit code handling</li> <li>Core command execution logic</li> </ul> <p>Follows Dependency Injection pattern:</p> <ul> <li><code>process_command</code> depends on abstraction (<code>Filter</code> protocol), not concrete implementation</li> <li>Makes testing trivial - can inject mock filters with predictable behavior</li> <li>Presentation layer controls which filter to use based on configuration</li> </ul> <p>Adheres to SOLID principles:</p> <ul> <li>Open/Closed: Can add new filter types without modifying <code>process_command</code></li> <li>Liskov Substitution: Any <code>Filter</code> implementation works identically from caller's perspective</li> <li>Dependency Inversion: Application layer depends on domain abstraction, not infrastructure implementation</li> </ul> <p>Minimal current overhead:</p> <p><code>PassThroughFilter</code> is trivial (~3 lines) and has zero performance impact. The abstraction adds clarity even for pass-through behavior: the code explicitly shows \"we're applying a filter, which happens to pass through unchanged\" rather than implicitly passing stdout.</p> <p>Clear extension point:</p> <p>The <code>Filter</code> protocol serves as documentation: \"This is where output transformation happens.\" Future developers immediately understand where LLM integration belongs.</p>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#implications","title":"Implications","text":""},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#positive-implications","title":"Positive Implications","text":"<ul> <li>Smooth LLM integration: Adding <code>LLMFilter</code> is straightforward - implement protocol and swap in CLI</li> <li>Testability: Can test filters independently; can test <code>process_command</code> with mock filters</li> <li>Flexibility: Easy to support multiple filter types (pass-through, LLM summarization, custom filters)</li> <li>Separation of concerns: Output transformation logic separated from command execution</li> <li>Type safety: Protocol provides IDE autocomplete and type checking</li> </ul>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#concerns","title":"Concerns","text":"<ul> <li>Slight complexity increase: Adds abstraction layer for currently-trivial behavior (mitigation: abstraction is minimal and will pay off immediately when LLM integration begins)</li> <li>Indirection: One extra function call (<code>filter.filter()</code>) in execution path (mitigation: negligible performance impact, clarity benefit outweighs cost)</li> </ul>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#alternatives","title":"Alternatives","text":""},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#direct-stdout-pass-through","title":"Direct stdout Pass-Through","text":"<p>Pass subprocess stdout directly to <code>write_stdout</code> without filter abstraction.</p> <pre><code>def main() -&gt; None:\n    result = run_command(args.command)\n    write_stdout(result.stdout)\n    sys.exit(result.returncode)\n</code></pre> <ul> <li>Pros: Simplest possible implementation, zero abstraction overhead</li> <li>Cons: LLM integration requires modifying <code>run_command</code>, CLI logic, and all tests; no clear extension point</li> <li>Reason for rejection: Known future requirement (LLM integration) makes abstraction worthwhile immediately</li> </ul>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#conditional-filter-application","title":"Conditional Filter Application","text":"<p>Check flag/config and conditionally apply filter.</p> <pre><code>def process_command(command, use_llm=False):\n    result = run_command(command)\n    if use_llm:\n        return llm_filter(result.stdout)\n    return result.stdout\n</code></pre> <ul> <li>Pros: No protocol needed, logic in one place</li> <li>Cons: Violates Open/Closed Principle; adding new filter types requires modifying <code>process_command</code>; harder to test</li> <li>Reason for rejection: Doesn't scale to multiple filter types; protocol-based approach is cleaner</li> </ul>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#strategy-pattern-with-base-class","title":"Strategy Pattern with Base Class","text":"<p>Use abstract base class instead of Protocol.</p> <pre><code>class Filter(ABC):\n    @abstractmethod\n    def filter(self, text: str) -&gt; str: ...\n</code></pre> <ul> <li>Pros: Enforces implementation via ABC; similar to Protocol approach</li> <li>Cons: Requires inheritance; Protocol is more Pythonic for duck typing; heavier-weight</li> <li>Reason for rejection: Protocol provides same benefits with lighter syntax; aligns with Python typing best practices</li> </ul>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#future-direction","title":"Future Direction","text":"<p>This abstraction should remain stable through LLM integration and beyond. Potential triggers for revisiting:</p> <ul> <li>Multiple transformation steps: If we need chaining (e.g., LLM summarization \u2192 Markdown formatting \u2192 Syntax highlighting), consider Composite Pattern or pipeline approach</li> <li>Streaming output: If we need to filter output as it streams (not batch), consider async generators or streaming protocols</li> <li>Context-aware filtering: If filters need access to command context (working directory, environment, history), consider enriching Filter protocol with context parameter</li> </ul> <p>For now, the simple <code>filter(text: str) -&gt; str</code> interface provides exactly what's needed for both pass-through and LLM summarization.</p>"},{"location":"adr/0007-introduce-filter-abstraction-for-output-processing/#references","title":"References","text":"<ul> <li>Issue #3: Implement basic pass-through mode</li> <li>ADR-0003: Adopt Layered Architecture</li> <li>Strategy Pattern</li> <li>Dependency Injection Principle</li> </ul>"},{"location":"adr/0008-introduce-llm-client-abstraction/","title":"ADR 0008: Introduce LLM Client Abstraction","text":""},{"location":"adr/0008-introduce-llm-client-abstraction/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0008-introduce-llm-client-abstraction/#date","title":"Date","text":"<p>2025-12-02</p>"},{"location":"adr/0008-introduce-llm-client-abstraction/#context","title":"Context","text":"<p>Issue #5 introduces LLM-based filtering using Ollama. Future requirements include support for multiple LLM providers (OpenAI, Claude, etc.).</p> <p>Without abstraction, domain layer would directly depend on Ollama-specific APIs (<code>ollama.Client</code>, <code>Message</code>, <code>ResponseError</code>), making provider switching difficult and leaking infrastructure details into domain logic.</p>"},{"location":"adr/0008-introduce-llm-client-abstraction/#decision","title":"Decision","text":"<p>Introduce <code>LLMClient</code> protocol in domain layer and <code>OllamaLLMClient</code> in infrastructure layer.</p> <pre><code>domain/\n  llm_client.py     # LLMClient protocol\n  filter.py         # LLMFilter depends on LLMClient\n\ninfrastructure/\n  ollama_client.py  # OllamaLLMClient implements LLMClient\n</code></pre> <p>LLMFilter (domain) depends on LLMClient protocol (domain). OllamaLLMClient (infrastructure) implements the protocol. Application layer injects client into filter.</p>"},{"location":"adr/0008-introduce-llm-client-abstraction/#rationale","title":"Rationale","text":"<ul> <li>Dependency Inversion: Domain depends on abstraction, not concrete infrastructure</li> <li>Extensibility: Adding providers requires only new infrastructure implementation, zero domain changes</li> <li>Testing: Domain tests mock simple protocol; infrastructure tests verify real integrations</li> <li>Encapsulation: Provider-specific details (auth, message formats, errors) isolated in infrastructure</li> </ul>"},{"location":"adr/0008-introduce-llm-client-abstraction/#implications","title":"Implications","text":""},{"location":"adr/0008-introduce-llm-client-abstraction/#positive-implications","title":"Positive Implications","text":"<ul> <li>Adding new providers requires no domain changes</li> <li>Domain tests use simple mocks</li> <li>Provider complexity isolated in infrastructure</li> </ul>"},{"location":"adr/0008-introduce-llm-client-abstraction/#concerns","title":"Concerns","text":"<ul> <li>Adds one layer of indirection (mitigation: negligible performance impact)</li> <li>Simple interface may not expose advanced features (mitigation: extend protocol when needed)</li> </ul>"},{"location":"adr/0008-introduce-llm-client-abstraction/#alternatives","title":"Alternatives","text":""},{"location":"adr/0008-introduce-llm-client-abstraction/#ollama-direct-in-domain-layer","title":"Ollama Direct in Domain Layer","text":"<ul> <li>Cons: Domain depends on infrastructure; adding providers requires domain changes</li> <li>Reason for rejection: Multiple provider support is planned</li> </ul>"},{"location":"adr/0008-introduce-llm-client-abstraction/#strategy-pattern-with-provider-enum","title":"Strategy Pattern with Provider Enum","text":"<ul> <li>Cons: Violates Open/Closed; provider logic mixed in domain</li> <li>Reason for rejection: Doesn't scale</li> </ul>"},{"location":"adr/0008-introduce-llm-client-abstraction/#abstract-base-class","title":"Abstract Base Class","text":"<ul> <li>Cons: Requires inheritance; less flexible than Protocol</li> <li>Reason for rejection: Protocol is more Pythonic</li> </ul>"},{"location":"adr/0008-introduce-llm-client-abstraction/#references","title":"References","text":"<ul> <li>Issue #5: Add LLM-based filtering with Ollama</li> <li>ADR-0003: Adopt Layered Architecture</li> <li>ADR-0007: Introduce Filter Abstraction for Output Processing</li> <li>Dependency Inversion Principle</li> </ul>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/","title":"ADR 0009: Silent Fallback to PassThrough Filter on Model Unavailability","text":""},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#date","title":"Date","text":"<p>2025-12-04</p>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#context","title":"Context","text":"<p>Issue #7 adds environment variable support for LLM model configuration (<code>SHTYM_LLM_SETTINGS__MODEL</code>).</p> <p>When the specified model is unavailable (not installed in Ollama, typo in model name, etc.), the application must decide whether to fail with an error or continue execution.</p> <p>Current implementation: <code>Application.create()</code> checks <code>OllamaLLMClient.is_available()</code>. If <code>False</code>, it silently falls back to <code>PassThroughFilter</code>.</p>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#decision","title":"Decision","text":"<p>When configured LLM model is unavailable, silently fall back to <code>PassThroughFilter</code> without warnings or errors.</p> <pre><code>@classmethod\ndef create(cls, command: list[str]) -&gt; \"Application\":\n    try:\n        llm_client = OllamaLLMClient.create()\n        if llm_client.is_available():\n            filter = LLMFilter(llm_client=llm_client)\n        else:\n            filter = PassThroughFilter()\n    except ImportError:\n        filter = PassThroughFilter()\n    return cls(command=command, filter=filter)\n</code></pre>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#rationale","title":"Rationale","text":"<ul> <li>Graceful degradation: User can continue work even when LLM unavailable</li> <li>Zero-configuration default: Works without Ollama installation</li> <li>No interruption: No manual intervention required when model missing</li> <li>Consistent behavior: Same fallback mechanism for all unavailability scenarios</li> </ul>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#implications","title":"Implications","text":""},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#positive-implications","title":"Positive Implications","text":"<ul> <li>Application never fails due to LLM configuration issues</li> <li>Smooth user experience in environments without LLM access</li> <li>No breaking changes when upgrading models or switching environments</li> </ul>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#concerns","title":"Concerns","text":"<ul> <li>Silent errors hide configuration mistakes (mitigation: add logging in future to warn when falling back to PassThroughFilter)</li> <li>Unexpected behavior when user expects LLM filtering but gets raw output (mitigation: add <code>--verbose</code> flag to show fallback notifications)</li> <li>Difficult debugging without indication that fallback occurred (mitigation: add <code>stym doctor</code> command to validate LLM configuration)</li> </ul>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#alternatives","title":"Alternatives","text":""},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#fail-with-error-on-model-unavailability","title":"Fail with Error on Model Unavailability","text":"<p>Behavior: Exit with error message when model unavailable.</p> <p>Pros: - User immediately aware of configuration issues - Explicit failure easier to debug than silent fallback</p> <p>Cons: - Breaks zero-configuration experience - Requires manual intervention for every configuration issue - Inconsistent with graceful degradation philosophy</p> <p>Reason for rejection: Prioritize availability over strict validation in initial implementation.</p>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#warn-but-continue","title":"Warn but Continue","text":"<p>Behavior: Print warning to stderr, then fall back to PassThroughFilter.</p> <p>Pros: - User notified of fallback - Still allows continued execution</p> <p>Cons: - Warning noise in logs/CI environments - May be ignored or filtered out - Complicates testing (need to assert stderr)</p> <p>Reason for rejection: Defer notification mechanism to future enhancement. Current simple behavior easier to test and reason about.</p>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#future-direction","title":"Future Direction","text":""},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#follow-up-actions","title":"Follow-up Actions","text":"<ol> <li>Add structured logging: Implement logging framework to warn when falling back to PassThroughFilter</li> <li>Add verbose mode: Implement <code>--verbose</code> flag to show fallback notifications</li> <li>Add diagnostic command: Implement <code>stym doctor</code> command to validate LLM configuration and report issues</li> <li>Add strict mode: Implement <code>--strict-llm</code> flag to fail fast when model unavailable</li> </ol>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#triggers-for-revisiting","title":"Triggers for Revisiting","text":"<p>This decision should be reconsidered when:</p> <ul> <li>Users report confusion about unexpected passthrough behavior</li> <li>Multiple bug reports about model configuration typos go unnoticed</li> <li>CI/CD pipelines require explicit validation of LLM availability</li> <li>Production deployments need guaranteed LLM filtering (no silent fallback)</li> </ul>"},{"location":"adr/0009-silent-fallback-to-passthrough-filter/#references","title":"References","text":"<ul> <li>Issue #7: Allow LLM model configuration via environment variable</li> <li>ADR-0007: Introduce Filter Abstraction for Output Processing</li> <li>ADR-0008: Introduce LLM Client Abstraction</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>This document provides a high-level overview of architectural decisions made for the shtym project.</p>"},{"location":"architecture/overview/#architecture-decision-records","title":"Architecture Decision Records","text":""},{"location":"architecture/overview/#adr-0001-keep-stdout-clean-for-ai-and-human-consumption","title":"ADR-0001: Keep stdout Clean for AI and Human Consumption","text":"<p>Status: Accepted | Date: 2025-11-20</p> <p>Keep stdout exclusively for AI-generated summaries, directing all other output to stderr for clean consumption by humans and AI agents.</p>"},{"location":"architecture/overview/#adr-0002-use-argparse-for-cli-implementation","title":"ADR-0002: Use argparse for CLI Implementation","text":"<p>Status: Accepted | Date: 2025-11-20</p> <p>Use Python's standard library argparse for CLI parsing to maintain zero external dependencies and align with the clean output philosophy.</p>"},{"location":"architecture/overview/#adr-0003-adopt-layered-architecture","title":"ADR-0003: Adopt Layered Architecture","text":"<p>Status: Accepted | Date: 2025-11-21</p> <p>Adopt a four-layer architecture (Presentation, Application, Domain, Infrastructure) to separate concerns, enable testing, and prepare for future LLM integration.</p>"},{"location":"architecture/overview/#adr-0004-do-not-implement-stdin-pipe-mode","title":"ADR-0004: Do Not Implement Stdin Pipe Mode","text":"<p>Status: Accepted | Date: 2025-11-21</p> <p>Use wrapper mode (<code>stym run command</code>) instead of pipe mode (<code>command | stym</code>) to enable exit code inheritance, which is critical for CI/CD integration.</p>"},{"location":"architecture/overview/#adr-0005-inherit-child-process-exit-codes","title":"ADR-0005: Inherit Child Process Exit Codes","text":"<p>Status: Accepted | Date: 2025-11-21</p> <p>Shtym must inherit and propagate the child process exit code exactly as-is, following Unix wrapper command conventions (sudo, timeout, time) for seamless CI/CD integration.</p>"},{"location":"architecture/overview/#adr-0006-adopt-subcommand-architecture","title":"ADR-0006: Adopt Subcommand Architecture","text":"<p>Status: Accepted | Date: 2025-11-21</p> <p>Adopt subcommand architecture (<code>stym run</code>, <code>stym status</code>, <code>stym config</code>) to enable future features without breaking changes or command ambiguity.</p>"},{"location":"architecture/overview/#adr-0007-introduce-filter-abstraction-for-output-processing","title":"ADR-0007: Introduce Filter Abstraction for Output Processing","text":"<p>Status: Accepted | Date: 2025-11-21</p> <p>Introduce Filter protocol with PassThroughFilter implementation now to minimize code changes when adding LLM integration, following Dependency Injection and SOLID principles.</p>"},{"location":"architecture/overview/#adr-0008-introduce-llm-client-abstraction","title":"ADR-0008: Introduce LLM Client Abstraction","text":"<p>Status: Accepted | Date: 2025-12-02</p> <p>Introduce LLMClient protocol in domain layer and OllamaLLMClient in infrastructure layer to decouple domain logic from specific LLM providers, enabling future support for OpenAI, Claude, and other providers.</p>"},{"location":"architecture/overview/#adr-0009-silent-fallback-to-passthrough-filter-on-model-unavailability","title":"ADR-0009: Silent Fallback to PassThrough Filter on Model Unavailability","text":"<p>Status: Accepted | Date: 2025-12-04</p> <p>When configured LLM model is unavailable, silently fall back to PassThroughFilter without warnings or errors, prioritizing graceful degradation and zero-configuration experience over strict validation.</p>"}]}