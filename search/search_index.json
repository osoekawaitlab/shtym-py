{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"shtym","text":"<p>AI-powered summary filter that distills any command\u2019s output.</p>"},{"location":"adr/0000-adr-template/","title":"ADR 0000: This is ADR Template and Short Title of the Architectural Decision Goes Here","text":""},{"location":"adr/0000-adr-template/#status","title":"Status","text":"<p>[Proposed | Accepted | Deprecated | Superseded]</p>"},{"location":"adr/0000-adr-template/#date","title":"Date","text":"<p>YYYY-MM-DD</p>"},{"location":"adr/0000-adr-template/#context","title":"Context","text":"<p>Describe the context and problem statement. What is the architectural challenge that needs to be addressed? Include any relevant constraints or requirements that influenced the decision.</p>"},{"location":"adr/0000-adr-template/#decision","title":"Decision","text":"<p>State the architectural decision clearly and concisely. What specific approach, technology, pattern, or solution was chosen?</p>"},{"location":"adr/0000-adr-template/#rationale","title":"Rationale","text":"<p>Explain the reasoning that led to this decision. Why was this particular option selected among the alternatives? Include relevant factors such as:</p> <ul> <li>Technical considerations</li> <li>Business requirements</li> <li>Team capabilities</li> <li>Time constraints</li> <li>Cost implications</li> </ul>"},{"location":"adr/0000-adr-template/#implications","title":"Implications","text":""},{"location":"adr/0000-adr-template/#positive-implications","title":"Positive Implications","text":"<p>List the benefits and positive outcomes expected from this decision.</p>"},{"location":"adr/0000-adr-template/#concerns","title":"Concerns","text":"<p>List potential challenges, risks, or negative consequences along with possible mitigation strategies.</p>"},{"location":"adr/0000-adr-template/#alternatives","title":"Alternatives","text":"<p>Describe other options that were considered and why they were not selected. For each alternative, briefly explain:</p> <ul> <li>Key characteristics</li> <li>Pros and cons relative to the chosen solution</li> <li>Reasons for rejection</li> </ul>"},{"location":"adr/0000-adr-template/#future-direction","title":"Future Direction","text":"<p>Outline any follow-up actions, future considerations, or potential changes that might be necessary as a result of this decision. Include potential triggers for revisiting this decision.</p>"},{"location":"adr/0000-adr-template/#references","title":"References","text":"<p>List any relevant documents, articles, books, or other resources that supported this decision:</p> <ul> <li>Links to relevant documentation</li> <li>Research materials</li> <li>Benchmarks or performance data</li> <li>Team discussions or meeting notes</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/","title":"ADR 0001: Keep stdout Clean for AI and Human Consumption","text":""},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#date","title":"Date","text":"<p>2025-11-20</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#context","title":"Context","text":"<p>The shtym tool is designed as a command-line filter that summarizes input using AI. Its primary purpose is to reduce context size for both human users and AI coding agents working in terminal environments. Users need to pipe command output through shtym and receive only the essential summary without any visual clutter or formatting.</p> <p>In modern development workflows, AI coding agents are increasingly consuming command-line output programmatically. Additionally, humans often need to copy-paste terminal output or chain commands together. Any extra formatting, progress indicators, or decorative elements in stdout would interfere with these use cases and defeat the purpose of context reduction.</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#decision","title":"Decision","text":"<p>Keep stdout exclusively for AI-generated summaries. All other output (progress indicators, error messages, logging, metadata) must go to stderr or other channels.</p>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#rationale","title":"Rationale","text":"<ul> <li>Context reduction goal: Adding any extra formatting to stdout would contradict the core purpose of reducing context size</li> <li>AI agent compatibility: AI coding agents can cleanly consume stdout without parsing decorative elements</li> <li>Unix philosophy: Following the principle that stdout carries the primary data output while stderr carries metadata</li> <li>Composability: Users can reliably pipe shtym output to other commands or redirect it to files</li> <li>Copy-paste friendliness: Humans can directly use the stdout content without manual cleanup</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#implications","title":"Implications","text":""},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clean integration with Unix pipes and redirections</li> <li>AI coding agents can parse output without special handling</li> <li>Predictable behavior: stdout always contains exactly the summary</li> <li>No dependency on terminal capabilities or detection logic</li> <li>Users can easily capture only the summary: <code>command | shtym &gt; summary.txt</code></li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#concerns","title":"Concerns","text":"<ul> <li>Users won't see progress indicators in stdout (mitigation: use stderr for progress)</li> <li>Debugging information must go to stderr (mitigation: implement proper logging levels)</li> <li>May feel \"bare\" compared to modern CLI tools with rich formatting (mitigation: this is intentional for our use case)</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#alternatives","title":"Alternatives","text":""},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#rich-cli-with-formatting-controls","title":"Rich CLI with formatting controls","text":"<p>Using libraries like rich or colorama to provide formatted output with an option to disable it.</p> <ul> <li>Pros: Better visual experience for interactive use, can show progress elegantly</li> <li>Cons: Adds complexity, requires terminal detection, users must remember to use <code>--plain</code> flags, increases dependencies</li> <li>Reason for rejection: Goes against the core philosophy of simplicity and context reduction</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#json-output-mode","title":"JSON output mode","text":"<p>Wrapping the summary in JSON with metadata fields.</p> <ul> <li>Pros: Machine-readable, can include metadata</li> <li>Cons: Increases output size, requires parsing, defeats context reduction purpose</li> <li>Reason for rejection: Contradicts the goal of minimal context; metadata can go to stderr if needed</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#mixed-output-with-delimiters","title":"Mixed output with delimiters","text":"<p>Using special delimiters to separate summary from other information in stdout.</p> <ul> <li>Pros: Can include both summary and metadata in one stream</li> <li>Cons: Users must parse delimiters, still increases output size, fragile</li> <li>Reason for rejection: Adds unnecessary complexity and increases context size</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#future-direction","title":"Future Direction","text":"<p>This decision is foundational and unlikely to change. However, we should:</p> <ul> <li>Implement proper stderr logging for progress and debug information</li> <li>Consider environment variables or config files for verbosity control (affecting stderr only)</li> <li>Document this design choice clearly for users and contributors</li> <li>Revisit if a compelling use case emerges that requires stdout metadata (trigger: multiple user requests for structured output)</li> </ul>"},{"location":"adr/0001-keep-stdout-clean-for-ai-and-human-consumption/#references","title":"References","text":"<ul> <li>Unix Philosophy: \"Write programs that do one thing and do it well\"</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/","title":"ADR 0002: Use argparse for CLI Implementation","text":""},{"location":"adr/0002-use-argparse-for-cli-implementation/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#date","title":"Date","text":"<p>2025-11-20</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#context","title":"Context","text":"<p>Following ADR-0001's decision to keep stdout clean, shtym needs a CLI argument parsing library. Python offers several options including the standard library's argparse, and third-party libraries like click and typer that provide rich terminal UI features.</p> <p>The tool's design philosophy emphasizes simplicity and minimal dependencies. Since shtym's primary function is piping input through AI summarization, the CLI surface area is intentionally small. Complex interactive features, auto-completion, or rich formatting would not align with the clean stdout principle established in ADR-0001.</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#decision","title":"Decision","text":"<p>Use argparse from Python's standard library for CLI argument parsing.</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#rationale","title":"Rationale","text":"<ul> <li>Zero external dependencies: argparse is part of Python's standard library, requiring no additional packages</li> <li>Sufficient functionality: Provides all necessary features (flags, options, help text, subcommands if needed)</li> <li>No rich UI features: Lack of built-in colors, prompts, and progress bars aligns with ADR-0001's philosophy</li> <li>Simplicity: Straightforward API without magic decorators or complex abstractions</li> <li>Stability: Part of the standard library with guaranteed long-term support</li> <li>Predictability: Well-documented behavior, no surprises from framework-specific conventions</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#implications","title":"Implications","text":""},{"location":"adr/0002-use-argparse-for-cli-implementation/#positive-implications","title":"Positive Implications","text":"<ul> <li>No dependency management overhead</li> <li>Works out-of-the-box in any Python environment</li> <li>Lightweight CLI with minimal overhead</li> <li>Clear, explicit argument definitions without decorators</li> <li>Easy to test with standard mocking techniques</li> <li>Reduces package size and installation complexity</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#concerns","title":"Concerns","text":"<ul> <li>Manual help text formatting (mitigation: acceptable trade-off for simplicity)</li> <li>No built-in shell completion (mitigation: can add via argcomplete if needed, but likely unnecessary for our simple CLI)</li> <li>More verbose than decorator-based frameworks (mitigation: explicit is better than implicit, aids readability)</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#alternatives","title":"Alternatives","text":""},{"location":"adr/0002-use-argparse-for-cli-implementation/#click","title":"Click","text":"<p>A popular third-party CLI framework with decorator-based API.</p> <ul> <li>Pros: Elegant decorator syntax, rich ecosystem, wide adoption</li> <li>Cons: External dependency, includes rich terminal features we don't need (colors, prompts, progress bars), adds framework magic</li> <li>Reason for rejection: Adds unnecessary dependency and features that contradict ADR-0001's clean output philosophy</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#typer","title":"Typer","text":"<p>Modern CLI framework built on top of Click with type hints.</p> <ul> <li>Pros: Type-safe, modern Python syntax, automatic help generation from type hints</li> <li>Cons: External dependency, even heavier than Click (depends on Click + rich), includes rich terminal UI we don't want</li> <li>Reason for rejection: Same concerns as Click, plus additional dependency weight and unwanted UI features</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#python-fire","title":"Python Fire","text":"<p>Automatically generates CLIs from Python objects.</p> <ul> <li>Pros: Zero boilerplate, automatic CLI generation</li> <li>Cons: External dependency, magic behavior, less explicit control, harder to understand CLI structure</li> <li>Reason for rejection: Too much magic, lack of explicit control contradicts our simplicity goal</li> </ul>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#future-direction","title":"Future Direction","text":"<p>This decision is expected to remain stable. Potential triggers for revisiting:</p> <ul> <li>Complex subcommand structure emerges: If shtym grows to require many subcommands with nested options, a richer framework might become beneficial (unlikely given the tool's focused scope)</li> <li>Shell completion becomes essential: If users strongly request shell completion, we could add argcomplete as an optional dependency</li> <li>Standard library evolution: If argparse gains significant improvements or a better alternative enters the standard library</li> </ul> <p>For now, argparse provides everything needed for shtym's straightforward CLI.</p>"},{"location":"adr/0002-use-argparse-for-cli-implementation/#references","title":"References","text":"<ul> <li>ADR-0001: Keep stdout Clean for AI and Human Consumption</li> <li>Python argparse documentation</li> <li>PEP 389: argparse - New Command Line Parsing Module</li> </ul>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>This document provides a high-level overview of architectural decisions made for the shtym project.</p>"},{"location":"architecture/overview/#architecture-decision-records","title":"Architecture Decision Records","text":""},{"location":"architecture/overview/#adr-0001-keep-stdout-clean-for-ai-and-human-consumption","title":"ADR-0001: Keep stdout Clean for AI and Human Consumption","text":"<p>Status: Accepted | Date: 2025-11-20</p> <p>Keep stdout exclusively for AI-generated summaries, directing all other output to stderr for clean consumption by humans and AI agents.</p>"},{"location":"architecture/overview/#adr-0002-use-argparse-for-cli-implementation","title":"ADR-0002: Use argparse for CLI Implementation","text":"<p>Status: Accepted | Date: 2025-11-20</p> <p>Use Python's standard library argparse for CLI parsing to maintain zero external dependencies and align with the clean output philosophy.</p>"}]}